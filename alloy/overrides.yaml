cluster: &clusterName deus-ex-machina-mgmt-prod
global:
  image:
    # registry: &imageRegistry "localregistry.machina-mgmt-prod.space:5000/docker"
    registry: &imageRegistry "docker.io"
  extraLabels: &extraLabels
    cluster: deus-ex-machina-mgmt-prod
    region: us-gov-west-1
  loki:
    service:
      url: "loki-gateway.logging.svc.cluster.local"
      protocol: "http"
      port: "80"
      prefix: "loki/api/v1/push"
    orgID: "1"
  prometheus:
    service:
      url: "mimir-nginx.monitoring.svc.cluster.local"
      protocol: "http"
      port: "80"
      prefix: "api/v1/push"
    orgID: "1"

alloy:
  clustering:
    # -- Deploy Alloy in a cluster to allow for load distribution.
    enabled: true
  mounts:
    # -- Mount /var/log from the host into the container for log collection.
    varlog: true
    # -- Mount /var/lib/docker/containers from the host into the container for log
    # collection.
    dockercontainers: true
  enableReporting: false
  #  storagePath: /data
  resources:
    requests:
      cpu: "0.5"
      memory: 1Gi
    limits:
      cpu: "2"
      memory: 2Gi
  configMap:
    # -- Create a new ConfigMap for the config file.
    create: true
    # -- Content to assign to the new ConfigMap.  This is passed into `tpl` allowing for templating from values.
    files:
      - k8s.alloy
      - ksm.alloy
      - nodes.alloy
    # - logs.alloy
    config: |
      prometheus.exporter.unix "default" { }
      prometheus.exporter.cadvisor "default" { }
      discovery.kubernetes "pods" {
        role = "pod"
      }

      discovery.kubernetes "nodes" {
        role = "node"
      }

      discovery.kubernetes "services" {
        role = "service"
      }

      discovery.kubernetes "endpoints" {
        role = "endpoints"
      }

      // discovery.kubernetes "endpointslices" {
      //   role = "endpointslice"
      // }

      // discovery.kubernetes "ingresses" {
      //   role = "ingress"
      // }

      k8s.cadvisor "scrape" {
        forward_to = [prometheus.remote_write.mimir.receiver]
        clustering = true
        job_label = "cadvisor"
      }

      k8s.resources "scrape" {
        forward_to = [prometheus.remote_write.mimir.receiver]
        clustering = true
        job_label = "kube-resources"
      }
      k8s.apiserver "scrape" {
        forward_to = [prometheus.remote_write.mimir.receiver]
        clustering = true
        job_label = "kube-apiserver"
      }
      k8s.probes "scrape" {
        forward_to = [prometheus.remote_write.mimir.receiver]
        clustering = true
        job_label = "kube-probes"
      }
      k8s.kube_dns "scrape" {
        forward_to = [prometheus.remote_write.mimir.receiver]
        clustering = true
        job_label = "kube-dns"
      }
      k8s.kubelet "scrape" {
        forward_to = [prometheus.remote_write.mimir.receiver]
        clustering = true
        job_label = "kube-kubelet"
      }

      ksm.kubernetes "targets" {}

      ksm.scrape "metrics" {
        targets     = ksm.kubernetes.targets.output
        forward_to  = [prometheus.remote_write.mimir.receiver]
        clustering = true
        job_label = "kube-state-metrics"
      }

      nodes.kubernetes "targets" {}

      nodes.scrape "metrics" {
        targets = nodes.kubernetes.targets.output
        forward_to = [prometheus.remote_write.mimir.receiver]
        clustering = true
        job_label = "node-exporter"
      }

      discovery.relabel "pods" {
        targets = discovery.kubernetes.pods.targets

        rule {
          source_labels = ["__meta_kubernetes_pod_controller_name"]
          regex         = "([0-9a-z-.]+?)(-[0-9a-f]{8,10})?"
          target_label  = "__tmp_controller_name"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name", "__meta_kubernetes_pod_label_app", "__tmp_controller_name", "__meta_kubernetes_pod_name"]
          regex         = "^;*([^;]+)(;.*)?$"
          target_label  = "app"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_instance", "__meta_kubernetes_pod_label_instance"]
          regex         = "^;*([^;]+)(;.*)?$"
          target_label  = "instance"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_component", "__meta_kubernetes_pod_label_component"]
          regex         = "^;*([^;]+)(;.*)?$"
          target_label  = "component"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_node_name"]
          target_label  = "node_name"
        }

        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          target_label  = "namespace"
        }

        rule {
          source_labels = ["namespace", "app"]
          separator     = "/"
          target_label  = "job"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_name"]
          target_label  = "pod"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_container_name"]
          target_label  = "container"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
          separator     = "/"
          target_label  = "__path__"
          replacement   = "/var/log/pods/*$1/*.log"
        }

        rule {
          source_labels = ["__meta_kubernetes_pod_annotationpresent_kubernetes_io_config_hash", "__meta_kubernetes_pod_annotation_kubernetes_io_config_hash", "__meta_kubernetes_pod_container_name"]
          separator     = "/"
          regex         = "true/(.*)"
          target_label  = "__path__"
          replacement   = "/var/log/pods/*$1/*.log"
        }
      }

      local.file_match "pods" {
        path_targets = discovery.relabel.pods.output
      }

      loki.source.file "pods" {
        targets               = local.file_match.pods.targets
        forward_to            = [loki.process.pods.receiver]
        legacy_positions_file = "/run/promtail/positions.yaml"
      }

      loki.process "pods" {
        forward_to = [loki.write.default.receiver]
      }

# Rempote write configuration gets created in _helpers.tpl and appended to end of Alloy config

image:
  registry: *imageRegistry
  repository: grafana/alloy
  tag: v1.5.0

configReloader:
  # -- Enables automatically reloading when the Alloy config changes.
  enabled: true
  image:
    registry: registry1.dso.mil
    repository: ironbank/opensource/jimmidyson/configmap-reload
    tag: v0.13.1

serviceMonitor:
  enabled: true

controller:
  tolerations:
    - key: "CriticalAddonsOnly"
      operator: "Equal"
      value: "true"
      effect: "NoExecute"
    - key: "cpu"
      operator: "Equal"
      value: "true"
      effect: "NoExecute"

  persistence:
    enabled: false
    storageClass: ebs-sc
    accessModes:
      - ReadWriteOnce
    resources:
      requests:
        storage: 10Gi
  volumes:
    # -- Extra volumes to add to the Grafana Alloy pod.
    extra: []
